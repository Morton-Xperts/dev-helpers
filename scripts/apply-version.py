#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Update app versions from package.json into:
  - versionInfo.js (commit hash + version)
  - .env (MAJOR_VERSION / MINOR_VERSION / PATCH_VERSION)

Mirrors the behavior of the provided Bash script, but uses only Python stdlib.
"""

import json
import re
import sys
from pathlib import Path
from subprocess import CalledProcessError, run
from typing import NoReturn

REPO_ROOT = Path(".").resolve()
PKG_JSON = REPO_ROOT / "package.json"
ENV_FILE = REPO_ROOT / ".env"
VERSIONINFO_JS = REPO_ROOT / "versionInfo.js"

SEMVER_NUMERIC_RE = re.compile(r"^(\d+)\.(\d+)\.(\d+)(?:$|-)")
ENV_LINE_RE = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*)=(.*)$")


def die(msg: str, code: int = 1) -> NoReturn:
    print(msg, file=sys.stderr)
    sys.exit(code)


def git_commit_short_hash() -> str:
    try:
        res = run(["git", "rev-parse", "--short", "HEAD"], check=True, capture_output=True, text=True)
        return res.stdout.strip()
    except FileNotFoundError:
        die("Error: git is required.")
    except CalledProcessError as e:
        die(f"Error: failed to get git commit hash: {e}")


def read_version_from_package_json(path: Path) -> str:
    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        die("Error: must be run from the repo root (package.json not found).")
    except json.JSONDecodeError as e:
        die(f"Error: package.json is not valid JSON: {e}")

    version = str(data.get("version", "")).strip()
    if not version:
        die("Error: could not determine version from package.json.")
    return version


def parse_semver_numeric(version: str):
    m = SEMVER_NUMERIC_RE.match(version)
    if not m:
        die(
            f"Error: version '{version}' is not X.Y.Z (numeric). Update the script if you use prerelease tags."
        )
    major, minor, patch = m.group(1), m.group(2), m.group(3)
    return major, minor, patch


def write_version_info_js(path: Path, commit_hash: str, version: str):
    content = (
        "// THIS FILE IS AUTO GENERATED BY CI\n"
        f"export const commitHash = '{commit_hash}';\n"
        f"export const version = '{version}';\n"
    )
    path.write_text(content, encoding="utf-8")
    print("Wrote versionInfo.js")


def set_kv(env_path: Path, key: str, value: str):
    """
    Set or add KEY=VALUE in a .env-like file.
    - If the file doesn't exist, create it with the single key.
    - If KEY exists, replace its line.
    - Otherwise, append KEY=VALUE.
    """
    if not env_path.exists():
        print(f"{env_path.name} not found; creating it.")
        env_path.write_text(f"{key}={value}\n", encoding="utf-8")
        return

    lines_changed = False
    new_lines = []

    with env_path.open("r", encoding="utf-8") as f:
        for line in f.readlines():
            m = ENV_LINE_RE.match(line.rstrip("\n"))
            if m and m.group(1) == key:
                new_lines.append(f"{key}={value}\n")
                lines_changed = True
            else:
                new_lines.append(line)

    if not lines_changed:
        if new_lines and not new_lines[-1].endswith("\n"):
            new_lines[-1] = new_lines[-1] + "\n"
        new_lines.append(f"{key}={value}\n")

    with env_path.open("w", encoding="utf-8") as f:
        f.writelines(new_lines)


def main():
    print("Updating app versions in Xcode project(s) and versionInfo.js")
    print("Run this from the repository root.")

    if not PKG_JSON.exists():
        die("Error: must be run from the repo root (package.json not found).")

    commit_hash = git_commit_short_hash()
    version = read_version_from_package_json(PKG_JSON)
    major, minor, patch = parse_semver_numeric(version)

    print(f"Updating to version {version} ({commit_hash})")

    write_version_info_js(VERSIONINFO_JS, commit_hash, version)

    set_kv(ENV_FILE, "MAJOR_VERSION", major)
    set_kv(ENV_FILE, "MINOR_VERSION", minor)
    set_kv(ENV_FILE, "PATCH_VERSION", patch)
    print(f"Updated {ENV_FILE.name}")

    print("Done.")


if __name__ == "__main__":
    main()


name: 'Version Bump'
description: |
  You must provide either the `package-file` or `version` parameter to indicate the current version of your
  artifact

inputs:
  git-email:
    description: 'Configured email address for git user'
    default: 'github-actions@github.com'
    required: false
  git-name:
    description: 'Configured name for git user'
    default: 'github-actions'
    required: false
  github-token:
    description: |
      GitHub token for pushing to the registry
    required: true
  package-file:
    description: |
      Path to the package.json file
    required: false
    default: 'package.json'
  bump-version:
    description: 'Whether to perform a version bump'
    required: false
    default: 'true'
  commit-and-push:
    description: 'Whether to commit, tag, and push changes'
    required: false
    default: 'true'

outputs:
  version:
    description: 'The current package version (semver) from the package file'
    value: ${{ steps.version.outputs.version }}

runs:
  using: "composite"

  steps:
    - name: 'Configure Git'
      shell: bash
      env:
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
      run: |
        git config --global user.email "${{ inputs.git-email }}"
        git config --global user.name "${{ inputs.git-name }}"
        git config --global push.followTags true

    - name: 'Increment Package Version'
      if: ${{ inputs.bump-version == 'true' }}
      shell: python
      env:
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        PACKAGE_FILE: ${{ inputs.package-file }}
      run: |
        import json, os, pathlib, re, sys

        def decide_level(message: str, default: str = "patch") -> str:
            msg = (message or "").strip().lower()
            if msg.startswith("major") or msg.startswith("refactor"):
                return "major"
            if msg.startswith("minor") or msg.startswith("feat"):
                return "minor"
            return default

        def bump(version: str, level: str) -> str:
            m = re.match(r"^(\d+)\.(\d+)\.(\d+)(.*)$", version)
            if not m:
                print(f"Error: version '{version}' is not in expected x.y.z format", file=sys.stderr)
                sys.exit(1)
            major, minor, patch, rest = m.groups()
            major, minor, patch = int(major), int(minor), int(patch)
            if level == "major":
                major += 1; minor = 0; patch = 0; rest = ""
            elif level == "minor":
                minor += 1; patch = 0; rest = ""
            else:
                patch += 1
            return f"{major}.{minor}.{patch}{rest}"

        pkg_path = pathlib.Path(os.environ.get("PACKAGE_FILE", "package.json"))
        commit_message = os.environ.get("COMMIT_MESSAGE", "")

        if not pkg_path.exists():
            print(f"Error: package file not found: {pkg_path}", file=sys.stderr)
            sys.exit(1)

        try:
            data = json.loads(pkg_path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"Error reading JSON from {pkg_path}: {e}", file=sys.stderr)
            sys.exit(1)

        version = data.get("version")
        if not isinstance(version, str):
            print("Error: 'version' not found in package file", file=sys.stderr)
            sys.exit(1)

        level = decide_level(commit_message)
        new_version = bump(version, level)

        if new_version != version:
            data["version"] = new_version
            pkg_path.write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")

        print(new_version)

    - name: 'Commit new Package Version'
      if: ${{ inputs.commit-and-push == 'true' }}
      shell: bash
      run: |
        PACKAGE_VERSION=$(jq -r ".version" ${{ inputs.package-file }})
        git commit -a -m "skip ci: version incremented to v$PACKAGE_VERSION [skip ci]"

    - name: 'Tag Sources'
      if: ${{ inputs.commit-and-push == 'true' }}
      shell: bash
      run: |
        PACKAGE_VERSION=$(jq -r ".version" ${{ inputs.package-file }})
        git tag -a "v$PACKAGE_VERSION" -m "skip ci: version tagged as v$PACKAGE_VERSION [skip ci]"

    - name: 'Push Changes to Git'
      if: ${{ inputs.commit-and-push == 'true' }}
      shell: bash
      run: |
        git push origin HEAD:${{ github.ref }} --force

    - name: 'Get Current Version'
      id: version
      shell: bash
      run: |
        PACKAGE_VERSION=$(jq -r ".version" ${{ inputs.package-file }})
        echo "Package version is: $PACKAGE_VERSION"
        echo "version=$(echo $PACKAGE_VERSION)" >> $GITHUB_OUTPUT

    - name: 'Create Release'
      if: ${{ inputs.commit-and-push == 'true' }}
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      with:
        tag_name: v${{ steps.version.outputs.version }}
        release_name: Release ${{ steps.version.outputs.version }}
        draft: false
        prerelease: false
